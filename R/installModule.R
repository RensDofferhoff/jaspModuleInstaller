createLocalRecord <- function(modulePkg, moduleInfo, cacheAble = TRUE, addJaspToVersion = TRUE) {
  record <- list(list(
    Package    = moduleInfo[["Package"]],
    Version    = if (addJaspToVersion) addLocalJaspToVersion(moduleInfo[["Version"]]) else moduleInfo[["Version"]],
    Source     = "Local",
    RemoteType = "local",
    RemoteUrl  = modulePkg,
    Cacheable  = cacheAble,
    Hash       = computeModuleHash(modulePkg)
  ))
  names(record) <- moduleInfo[["Package"]]
  record
}

updateLockFileWithLocalJaspModules <- function(lockfile, pathToModule) {

  engineRoot <- normalizePath(file.path(pathToModule, "..", "..", "Engine"))
  modulePaths <- c(
    file.path(engineRoot, "jaspGraphs"),
    file.path(engineRoot, "jaspBase"),
    pathToModule
  )

  modulePaths <- union(modulePaths, extractModuleDependenciesFromStatusObject(pathToModule))

  records <- vector("list", length(modulePaths))
  for (i in seq_along(modulePaths)) {

    modulePath <- modulePaths[i]
    moduleInfo <- getModuleInfo(modulePath)
    record <- createLocalRecord(modulePath, moduleInfo)
    records[i] <- record
    names(records)[i] <- names(record)

  }

  updatedLockfile <- renv::record(records = records, lockfile = lockfile)
  return(updatedLockfile)
}

cleanModuleLibrary <- function() {
  identical(toupper(Sys.getenv("JASP_CLEAN_MODULE_LIBRARY", unset = "TRUE")), "TRUE")
}

getInstallMode <- function() {
  return("localJaspPackages")
}

#' @export
installJaspModule <- function(modulePkg, moduleLibrary, repos, onlyModPkg, force = FALSE, frameworkLibrary = NULL) {

  validateCompilationAbilities()

  isPkgArchive <- isModulePkgArchive(modulePkg)
  assertValidJASPmodule(modulePkg)

  r <- getOption("repos")
  r["CRAN"] <- repos
  options(repos = r)

  # if (!isPkgArchive && !(force || md5SumsChanged(modulePkg, moduleLibrary))) {
  #   moduleName <- getModuleInfo(modulePkg)[["Package"]]
  #   if (dir.exists(file.path(moduleLibrary, moduleName))) {
  #     print(sprintf("Nothing changed according to md5sums, not reinstalling %s.", moduleName))
  #     return("succes!")
  #   } else {
  #     print(sprintf("Checksums exist for %s but the package is missing, installing anyway!", moduleName))
  #   }
  # }

  maybeBuildTools <- if (require("pkgbuild", quietly = TRUE)) {
    function(x) getFromNamespace("with_build_tools", "pkgbuild")(x, required = FALSE)
  } else {
    identity
  }

  tryCatch({
    maybeBuildTools({
      installJaspModuleImpl(modulePkg, moduleLibrary, repos, onlyModPkg)
      # if (hasRenvLockFile(modulePkg)) installJaspModuleFromRenv(       modulePkg, libPathsToUse, moduleLibrary, repos, onlyModPkg)
      # else                            installJaspModuleFromDescription(modulePkg, libPathsToUse, moduleLibrary, repos, onlyModPkg, frameworkLibrary = frameworkLibrary)
    })
  }, error = function(e) {
    if (is.null(e[["output"]])) {
      stop(e, domain = NA)
    } else {
      return(stop(e[["output"]], domain = NA))
    }
  })

  return(invisible(TRUE))
}

installJaspModuleImpl <- function(modulePkg, moduleLibrary, repos, onlyModPkg) {

  cat(sprintf(
    "Installing module with renv.\ninstallJaspModuleImpl('%s', '%s', '%s', %s)\nwith libPaths:\n%s\n",
    modulePkg, moduleLibrary, repos, onlyModPkg,
    paste(.libPaths(), collapse = ", ")
  ))

  setupRenv(moduleLibrary, modulePkg)
  loadModuleStatusObject()
  installMode <- getInstallMode()

  clean <- cleanModuleLibrary()
  moduleName <- getModuleName(modulePkg)

  lockfilePath <- getRenvLockFile(modulePkg)

  if (!file.exists(lockfilePath))
    generateBasicLockfile2(lockfilePath, modulePkg, moduleLibrary)
    # generateBasicLockfile(lockfilePath, modulePkg)

  lockfile <- renv::lockfile_read(lockfilePath)
  updatedLockfile <- updateLockFileWithLocalJaspModules(lockfile, modulePkg)

  libs <- .libPaths()
  library <- c(moduleLibrary, libs[length(libs)])

  if (installMode == "identicalToLockfile") {

    # install remote versions of jasp module dependencies but local version of the module
    renv::restore(lockfile = lockfilePath,     exclude = moduleName, clean = clean, library = library)
    renv::restore(lockfile = updatedLockfile, packages = moduleName, clean = clean, library = library)

  } else if (installMode == "localJaspPackages") {

    # install local versions of jasp module and jasp module dependencies
    records <- renv::restore(lockfile = updatedLockfile,  clean = clean, library = library)

  }

  # if (isAutoGenerated(lockfile)) {
  #
  #   updatedLockfile <- renv::record(records = records, lockfile = updatedLockfile)
  #
  #   cat("Autogenerated lockfile, updating all packages.\n")
  #   records <- renv::update(project = modulePkg)
  #
  #   if (is.list(records) && !is.logical(records))
  #     updatedLockfile <- renv::record(records = records, lockfile = updatedLockfile)
  #
  #   renv::lockfile_write(lockfile = updatedLockfile, file = lockfilePath)
  #
  # }

}

generateBasicLockfile <- function(lockfilePath, modulePkg) {

  warning("Creating a basic lockfile and adding it to the module. ",
          "Please manage this yourself and remove the key 'JASP'.",
          domain = NA)

  deps <- renv::dependencies(path = file.path(modulePkg, "DESCRIPTION"))
  pkgs <- unique(deps$Package)

  lst <- tools::package_dependencies(pkgs, recursive = TRUE)

  # does _not_ include GitHub dependencies
  mostPkgs <- sort(Reduce(union, lst))

  # base package should not end up in the lockfile, because in renv::restore() the comparison lockfile
  # never includes these and so they get up 'installed' every single time (nothing happens but they just shouldn't be recorded)
  basePkgs <- installed.packages(priority = "base")[, "Package"]
  mostPkgs <- setdiff(mostPkgs, basePkgs)

  lockfile <- renv::lockfile_create(project = modulePkg, type = "explicit")

  lockfile$Packages <- list()
  lockfile$JASP     <- list(autogenerated = TRUE) # makes isAutoGenerated work

  renv::lockfile_write(lockfile, lockfilePath)
  renv::record(mostPkgs,         lockfilePath)

}

isAutoGenerated <- function(lockfile) {
  isTRUE(lockfile[["JASP"]][["autogenerated"]])
}

extractModuleDependenciesFromStatusObject <- function(pathToModule) {

  moduleStatusObject <- getOption("jaspModuleInstallerModuleStatusObject")
  if (is.null(moduleStatusObject))
    stop("module status object does not exist but is required for autogenerating lockfiles.", domain = NA)

  pathsToAdd <- moduleStatusObject[["dependencies"]][[basename(pathToModule)]]

  if (is.null(pathsToAdd) || !all(file.exists(pathsToAdd)))
    warning(sprintf(
      "The module %s depends on other jasp modules (%s) but these do not exist locally in the Modules folder! Most likely these will be downloaded from GitHub.",
      basename(pathToModule),
      paste(basename(pathsToAdd[!file.exists(pathsToAdd)]), collapse = ", ")
    ))

  return(pathsToAdd)

}

generateBasicLockfile2 <- function(lockfilePath, modulePkg, moduleLibrary) {

  warning("Creating a basic lockfile by installing the module and unnecessarily installing GitHub dependencies. ",
          "Please manage this lockfile yourself!",
          domain = NA)

  renv::install(packages = modulePkg, library = moduleLibrary, project = modulePkg)

  libs <- .libPaths()
  library <- c(moduleLibrary, libs[length(libs)])

  renv::update(project = modulePkg, library = library)

  # renv::config$snapshot.validate(FALSE)
  # exclude jaspTools because it is often used in the unit tests but rarely specified correctly, so let's not snapshot it
  # use force = TRUE because testthat is also often incorrectly specified...
  # tf <- tempfile(pattern = basename(modulePkg))
  # dir.create(tf)
  # on.exit(unlink(tf))
  renv::snapshot(library = library, lockfile = lockfilePath, type = "all")#project = tf)

  # renv::config$snapshot.validate(TRUE)

}
